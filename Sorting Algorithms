#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm> // for default sort
#include <random> //for random
#include <chrono> //for time

std::ifstream in("tests.txt");
//std::ofstream out("results2.txt");

//rezultatele sunt doar pentru inputuri complet random
//ar trebuii sa verificam si pt inputuri semi-sortate

//de asemenea cred ca putem optimiza mergesortul cu niste referinte

//desi am facut template la functii momentan merge doar pe int din cauza function pointerului
//template<typename Type>
typedef void (*FunctionPointer)(std::vector<int>&);
std::vector<std::pair<std::string,FunctionPointer>> sorts;
std::vector<std::pair<int, long long int>> tests;


namespace Merge {
	template <typename Type>
	std::vector<Type> merge(std::vector<Type>& v1, std::vector<Type>& v2) {
		std::vector<Type> vec;
		int i = 0, j = 0;
		while (i < v1.size() && j < v2.size()) {
			if (v1[i] < v2[j]) {
				vec.push_back(v1[i]);
				i++;
			}
			else {
				vec.push_back(v2[j]);
				j++;
			}
		}
		while (i < v1.size()) {
			vec.push_back(v1[i]);
			i++;
		}
		while (j < v2.size()) {
			vec.push_back(v2[j]);
			j++;
		}
		return vec;
	}

	template <typename Type>
	std::vector<Type> merge_sort(std::vector<Type>& vec, int l, int r) {
		std::vector<Type> v1, v2;
		if (l < r) {
			int mij = (l + r) / 2;
			v1 = merge_sort(vec, l, mij);
			v2 = merge_sort(vec, mij + 1, r);
			return merge(v1, v2);
			//return merge(merge_sort(vec, l, mij), merge_sort(vec, mij + 1, r));
		}
		else {;
			return {vec[l]};
		}
	}

	template <typename Type>
	void mergeSort(std::vector<Type>& vec) {
		vec = merge_sort(vec,0,vec.size()-1);
	}
}
namespace Quick {
	template <typename Type>
	void swap(Type& x, Type& y) {
		Type z = x;
		x = y;
		y = z;
	}

	template <typename Type>
	void quick_sort(std::vector<Type>& vec, int l, int r) {
		if (l < r) {
			int pivot = r; //pivot selection
			int j = l - 1;
			for (int i = l; i < r; i++) {
				if (vec[i] < vec[pivot]) {
					j++;
					swap(vec[i], vec[j]);
				}
			}
			j++;
			swap(vec[pivot], vec[j]);

			quick_sort(vec, l, j - 1);
			quick_sort(vec, j + 1, r);
		}
	}

	template <typename Type>
	void quickSort(std::vector<Type>& vec) {
		quick_sort(vec, 0, vec.size() - 1);
	}
}
namespace Bubble {
	template <typename Type>
	void swap(Type& x, Type& y) {
		Type z = x;
		x = y;
		y = z;
	} 
	
	template<typename Type>
	void bubbleSort(std::vector<Type>& vec) {
		bool swapped = true;
		while (swapped) {
			swapped = false;
			for (int i = 0; i < vec.size() - 1; i++) {
				if (vec[i] > vec[i+1]) {
					swap(vec[i], vec[i+1]);
					swapped = true;
				}
			}
		}
	}

	template<typename Type>
	void bubbleSort2(std::vector<Type>& vec) {
		for (int i = 0; i < vec.size(); i++) {
			for (int j = i + 1; j < vec.size(); j++) {
				if (vec[i] > vec[j]) {
					swap(vec[i], vec[j]);
				}
			}
		}
	}

}
namespace Heap {
	template <typename Type>
	class Heap {
	private:
		// this is a min heap
		std::vector<Type> heap;
	public:
		Heap() : heap{ 0 } {}

		void swap(Type& x, Type& y) {
			Type z = x;
			x = y;
			y = z;
		}

		Type pop() {
			Type x = heap[1];
			int ind = 1;
			int son = 2;
			swap(heap[1], heap[heap.size() - 1]);
			heap.erase(heap.begin() + heap.size() - 1);
			if (son < heap.size()) {
				if (son + 1 < heap.size() && heap[son] > heap[son + 1]) {
					son++;
				}
				while (heap[son] < heap[ind]) {
					swap(heap[son], heap[ind]);
					ind = son;
					son = ind * 2;
					if (son >= heap.size()) { break; }
					if (son + 1 < heap.size() && heap[son] > heap[son + 1]) {
						son++;
					}
				}
			}
			return x;
		}

		void add(Type x) {
			int ind = heap.size();
			heap.push_back(x);
			while (heap[ind] < heap[ind / 2] && ind > 1) {
				swap(heap[ind], heap[ind / 2]);
				ind /= 2;
			}
		}

	};

	template <typename Type>
	void heapSort(std::vector<Type>& vec) {
		Heap<Type> heap;
		for (int i = 0; i < vec.size(); i++) {
			heap.add(vec[i]);
		}
		for (int i = 0; i < vec.size(); i++) {
			vec[i] = heap.pop();
		}
	}
}
namespace Insertion {
	
	template <typename Type>
	void insertionSort(std::vector<Type>& vec) {
		for (int i = 1; i < vec.size(); i++) {
			int j = i - 1;
			Type x = vec[i];
			while (j >= 0 && x < vec[j]) {
				vec[j + 1] = vec[j];
				j--;
			}
			vec[j + 1] = x;
		}
	}

	template <typename Type>
	void shellSort(std::vector<Type>& vec) {
		for (int gap = vec.size() / 2; gap > 0; gap /= 2) {
			for (int i = gap; i < vec.size(); i++) {
				int j = i - gap;
				Type x = vec[i];
				while (j >= 0 && x < vec[j]) {
					vec[j + gap] = vec[j];
					j-=gap;
				}
				vec[j + gap] = x;
			}
		}
	}
}


template <typename Type>
void print(std::vector<Type>& vec) {
	for (int j = 0; j < vec.size(); j++) {
		std::cout << vec[j] << " ";
	}
	std::cout << std::endl;
}

template <typename Type>
bool test_sort(std::vector<Type>& numbers, std::vector<Type>& sorted_numbers) {
	for (int i = 0; i < numbers.size(); i++) {
		if (numbers[i] != sorted_numbers[i]) { return false; }
	}
	return true;
}



int main()
{
	//sorts.push_back({ "Bubble1",&Bubble::bubbleSort});
	//sorts.push_back({ "Bubble2",&Bubble::bubbleSort2 });
	//sorts.push_back({ "Insert",&Insertion::insertionSort });
	sorts.push_back({ "Quick", &Quick::quickSort });
	sorts.push_back({ "Shell",&Insertion::shellSort });
	sorts.push_back({ "Heap ", &Heap::heapSort });
	sorts.push_back({ "Merge", &Merge::mergeSort });

	int nr_of_tests, n;
	long long int maxi;
	in >> nr_of_tests;
	for (int i = 0; i < nr_of_tests; i++) {
		in >> n >> maxi;
		std::cout << std::endl << " --- Test Nr: " << i << " \tN = " << n << "\tMAX = " << maxi << std::endl;
		if (maxi < INT32_MAX) {
			long long x;
			// generate random numbers
			std::random_device rd;  // Seed for the random number generator
			std::mt19937 rng(rd()); // Mersenne Twister engine
			std::uniform_int_distribution<int> distribution(1, maxi+1);

			std::vector<int> numbers, sorted_numbers, numbers_to_sort;
			for (int j = 0; j < n; j++) {
				//x = rand() % (maxi + 1);
				x = distribution(rng);
				numbers.push_back(x);
				sorted_numbers.push_back(x);
			}
			// sort them using default function
			auto start_time = std::chrono::high_resolution_clock::now();
			sort(sorted_numbers.begin(), sorted_numbers.end());
			auto end_time = std::chrono::high_resolution_clock::now();
			auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
			std::cout << "defaultSort time: " << duration.count() << " miliseconds"<<std::endl;
			//print(sorted_numbers);

			// sort the with other functions
			for (auto& sort_function : sorts) {
				numbers_to_sort.clear();
				numbers_to_sort = numbers;
				auto start_time = std::chrono::high_resolution_clock::now();
				sort_function.second(numbers_to_sort);
				auto end_time = std::chrono::high_resolution_clock::now();
				auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
				std::cout <<sort_function.first<<"Sort time: " << duration.count() << " miliseconds";

				// check if the sort was correct
				bool succesful = test_sort(numbers_to_sort, sorted_numbers);
				if (succesful) { std::cout << "\tSuccesful" << std::endl; }
				else { std::cout << "\tWRONG" << std::endl; }
			}
			
		}
		else {
			std::vector<long long> numbers;
		}
	}
	return 0;
}
